
/** 
 * An Egyptian fraction is a finite sum of distinct unit fractions, such as
 * 1 / 2 + 1 / 3 + 1 / 16 . 
 * That is, each fraction in the expression has a numerator equal to 1 and a denominator 
 * that is a positive integer, and all the denominators differ from each other. 
 * (source wikipedia)
 * 
 * with this in mind, egyptianUnitFraction will find fraction units by using recursion. 
 * 
 * Author: Ahmad Hussein Rezae
*/
const egyptianUnitFraction = (numerator, denominator) => {
    if(typeof numerator !== 'number' || typeof denominator !== 'number') {
        return new Error('Inputs must be numbers !')
    } else {
        if(denominator == 0)
            return new Error('The denominator can\'t be 0 !')
    
        if(numerator == 0)
            return 0
        
        if(numerator < 0 || denominator < 0)
            return new Error('Numbers should be positive !')
        
        /**
         * fractionResults array will store all fractions found in each function call
         * at end of each function call this array will be returned as function result
         * the higher function will concatenate it's array with the result( which is instance of this array) returned by function call
         * and it will return the concatenated array to higher function until it reachs the initial point
         */
        let fractionResults = []
        if(numerator % denominator == 0) {

            //push new found fraction object into fractionResults
            fractionResults.push({ 
                operation: `${numerator} / ${denominator}`, 
                result: { 
                    'numerator':numerator / denominator, 
                    'denominator':1
                 }
            })  
        } else {
            if(numerator > denominator) {

                /**
                 * push new found fraction object into fractionResults
                 * and call egyptianUnitFraction again with new arguments
                 */
                fractionResults.push({ 
                    operation: `RoundDown(${numerator} / ${denominator})`, 
                    result: { 
                        'numerator': Math.floor(numerator / denominator), 
                        'denominator':1 
                    } 
                })

                /**
                 * call egyptianUnitFraction with new numerator and denominator.
                 * on callback function result returned by this function call will be concatenated with fractionResults
                 */ 
                egyptianUnitFraction(
                    numerator % denominator, 
                    denominator
                ).map((item) => fractionResults.push(item))

            } else {
                if(denominator % numerator == 0) {

                    //push new found fraction object into fractionResults
                    fractionResults.push({ 
                        operation: `1 / (${denominator} / ${numerator})`, 
                        result: { 
                            'numerator': 1, 
                            'denominator':denominator / numerator 
                        } 
                    })
                } else {

                    //find nearest divisable portion of denominator to numerator
                    let devisiablePortion = Math.floor(denominator/numerator) + 1

                    /**
                     * push new found fraction object into fractionResults
                     * and call egyptianUnitFraction again with new arguments
                     */
                    fractionResults.push({ 
                        operation: `1 / RoundDown(${denominator} / ${numerator} + 1)`, 
                        result: { 
                            'numerator': 1, 
                            'denominator':devisiablePortion 
                        } 
                    })

                    /**
                     * call egyptianUnitFraction with new numerator and denominator.
                     * on callback function result returned by this function call will be concatenated with fractionResults
                     */ 
                    egyptianUnitFraction(
                        (numerator*devisiablePortion) - denominator, 
                        denominator * devisiablePortion
                    ).map((item) => fractionResults.push(item))

                }
            }
        }
        return fractionResults
    }
}

exports.egyptianUnitFraction = egyptianUnitFraction
